commonfields:
  id: IpInfoGenraterkdsajik
  version: -1
name: IpInfoGenraterkdsajik
display: IpInfoGenraterkdsajik
deprecated: false
beta: false
category: Endpoint
fromversion: 6.5.0
toversion: null
image: null
description: ""
defaultmapperin: null
defaultmapperout: null
defaultclassifier: null
detaileddescription: ""
autoconfiginstance: false
configuration:
  - display: Base URL
    defaultvalue: https://ipinfo.io
    name: base_url
    type: 0
    required: true
    hidden: false
    additionalinfo: ""
  - display: Context Key
    defaultvalue: IPInfo
    name: context_key
    type: 0
    required: true
    hidden: false
    additionalinfo: ""
  - display: Insecure
    defaultvalue: false
    name: insecure
    type: 8
    required: false
    hidden: false
    additionalinfo: ""
  - display: Use proxy
    defaultvalue: false
    name: proxy
    type: 8
    required: false
    hidden: false
    additionalinfo: ""
script:
  script: >
    from pathlib import Path

    from typing import Union



    class Constants:
        body = 'body'
        auth_custom = 'auth_custom'
        auth_format = 'auth_format'
        authentication_type = '_auth_type'
        auth_header_key = 'Authorization'
        password_placeholder = ':password'
        username_placeholder = ':username'
        auth_bearer = 'Bearer'
        auth_basic = 'Basic'
        auth_none = 'None'
        context_key = 'context_key'
        method = 'method'
        suffix = 'suffix'
        post_process = '_post_process'
        pre_process = '_pre_process'
        base_url = 'base_url'
        insecure = 'insecure'
        proxy = 'proxy'


    from enum import Enum, auto



    def load_json(path: Union[str, Path]):
        with Path(path).open() as f:
            return load_json(f)


    from typing import NamedTuple


    DEFAULT_POST_PROCESS = '''import requests



    class PostProcess:
        @staticmethod
        def post_process(response: requests.Response) -> CommandResults:
            # manipulate json if necessary, just make sure to return CommandResults
            json = response.json()
            return CommandResults(outputs_prefix=demisto.getParam('context_key'),
                                  outputs=json,
                                  raw_response=json)
    '''

    DEFAULT_PRE_PROCESS = '''


    class PreProcess:
        def __init__(self, args: ParsedArguments) -> None:
            self._args = args

        def get_preprocessed_args(self):
            # If necessary, change self._args
            # (the ParsedArguments object is immutable, but its members are mutable)
            return self._args
    '''



    class Prefixes:
        bearer = 'bearer'

        body_arg = '_body_arg'
        custom_arg = '_custom_arg'
        path_param = '_path_param'
        request_arg = '_request_arg'  # todo jochman

        header = '_header'
        authorization = 'authorization'
        configuration = 'configuration'
        pre_process = 'preprocess'
        post_process = 'preprocess'


    class ParsedArguments(NamedTuple):
        path_args: dict
        custom_args: dict
        request_args: dict
        body_args: dict


    class AuthenticationType(Enum):
        Basic = auto()
        Bearer = auto()
        Custom = auto()
        NoAuth = auto()


    class Parser:
        def __init__(self, params: dict, args: dict):
            self._params = params
            self._args = args

            self.base_url = params.get(Constants.base_url)
            self.insecure = params.get(Constants.insecure, False)  # todo argtobool
            self.proxy = params.get(Constants.proxy, False)

            self.method = args.get(Constants.method)
            self.body = args.get(Constants.body)
            self.context_key = args.get(Constants.context_key)
            self._parsed_arguments = self.parse_special_args(args)

            self.headers = Parser._extract_headers(args) | Parser._extract_headers(params) | self.generate_auth_header()
            self.suffix = self._parse_replace_suffix(args)

            # todo pass token as url path param
            self._pre_process_code = args.get(Constants.pre_process) or DEFAULT_PRE_PROCESS
            self._post_process_code = args.get(Constants.post_process) or DEFAULT_POST_PROCESS

            exec(self._pre_process_code, globals())  # imports the customized PreProcess class
            exec(self._post_process_code, globals())  # imports the customized PostProcess class

            # noinspection PyUnresolvedReferences
            self.pre_processor = PreProcess(self._parsed_arguments)
            # noinspection PyUnresolvedReferences
            self.post_processor = PostProcess()

        def generate_auth_header(self):
            auth_format = self._params.get(Constants.auth_format)
            authentication_type = self._parse_authentication_type(self._params)

            if auth_format and authentication_type != AuthenticationType.Custom:
                raise ValueError(f"Cannot have auth format with a non-custom authentication type {authentication_type}")

            if authentication_type == AuthenticationType.NoAuth:
                return dict()

            username = self._params.get('credentials', {}).get('username', '')
            password = self._params.get('credentials', {}).get('password', '')

            auth_type_to_auth_format = {
                AuthenticationType.Basic: f'Basic {Constants.username_placeholder}:{Constants.password_placeholder}',
                AuthenticationType.Bearer: f'Bearer {Constants.password_placeholder}',
                AuthenticationType.Custom: auth_format
            }
            try:
                auth_format = auth_type_to_auth_format[authentication_type]
            except KeyError:
                raise ValueError(f"Unexpected auth type={authentication_type}")

            if not auth_format:
                raise ValueError(f"Empty auth_format, auth type={authentication_type}")

            auth_header_value = auth_format \
                .replace(Constants.password_placeholder, password) \
                .replace(Constants.username_placeholder, username)

            return {Constants.auth_header_key: auth_header_value}

        @staticmethod
        def _parse_authentication_type(params: dict):
            raw_authentication_type = params.get(Constants.authentication_type, Constants.auth_none)

            string_to_type = {Constants.auth_basic: AuthenticationType.Basic,
                              Constants.auth_bearer: AuthenticationType.Bearer,
                              Constants.auth_none: AuthenticationType.NoAuth,
                              Constants.auth_custom: AuthenticationType.Custom}

            return string_to_type[raw_authentication_type]

        def _parse_replace_suffix(self, args):  # call after calling parse_special_args()
            suffix = args.get(Constants.suffix)
            for k, v in self._parsed_arguments.path_args.items():
                suffix = suffix.replace(f':{k}', v)
            return suffix

        @staticmethod
        def parse_special_args(args):
            path_params = {}
            custom_args = {}
            request_args = {}
            body_args = {}

            prefix_to_dict = {
                f'{Prefixes.path_param}:': path_params,
                f'{Prefixes.custom_arg}:': custom_args,
                f'{Prefixes.request_arg}:': request_args,
                f'{Prefixes.body_arg}:': body_args
            }

            for k, v in args.items():
                for prefix, destination in prefix_to_dict.items():
                    if k.startswith(prefix):
                        destination[k.removeprefix(prefix)] = v
                        break

            return ParsedArguments(path_args=path_params, custom_args=custom_args,
                                   request_args=request_args, body_args=body_args)

        @staticmethod
        def _extract_headers(data: dict):
            result = dict()
            result.update({k.removeprefix(f'{Prefixes.header}:'): v
                           for k, v in data.items()
                           if k.startswith(f'{Prefixes.header}:')})
            return result


    class PreProcess:
        def __init__(self, args: ParsedArguments) -> None:
            self._args = args

        def get_preprocessed_args(self):
            # If necessary, change self._args
            # (the ParsedArguments object is immutable, but its members are mutable)
            return self._args


    class ApiCall:
        @staticmethod
        def __call__(method: str,
                     url: str = None,
                     headers=None,
                     data=None,
                     verify: bool = True,
                     proxy: bool = False,
                     **kwargs) -> requests.Response:
            return requests.request(method=method, url=url, data=data, headers=headers)


    import requests



    class PostProcess:
        @staticmethod
        def post_process(response: requests.Response) -> CommandResults:
            # manipulate json if necessary, just make sure to return CommandResults
            json = response.json()
            return CommandResults(outputs_prefix=demisto.getParam('context_key'),
                                  outputs=json,
                                  raw_response=json)


    from urllib.parse import urljoin



    class Runner:
        def __init__(self):
            self.parser = Parser(params=demisto.params(), args=demisto.args())

        def run(self):
            args = self.parser.pre_processor.get_preprocessed_args()

            raw_response = ApiCall()(
                method=self.parser.method,
                url=urljoin(self.parser.base_url, self.parser.suffix),
                headers=self.parser.headers,
                data=self.parser.body,
                verify=not self.parser.insecure,
                proxy=self.parser.proxy,
                params=args.request_args
            )

            return self.parser.post_processor.post_process(raw_response)


    runner = Runner()

    results = runner.run()

    return_results(results)
  type: python
  dockerimage: demisto/python3:3.9.7.24076
  dockerimage45: null
  alt_dockerimages: null
  isfetch: false
  longRunning: false
  longRunningPort: null
  ismappable: false
  isremotesyncin: false
  isremotesyncout: false
  commands:
    - name: ipinfogenraterkdsajik-get-ip
      execution: false
      description: ""
      deprecated: false
      system: false
      arguments:
        - name: method
          required: false
          default: false
          description: ""
          auto: null
          predefined: []
          isArray: false
          defaultValue: GET
          secret: false
          deprecated: false
        - name: suffix
          required: false
          default: false
          description: ""
          auto: null
          predefined: []
          isArray: false
          defaultValue: :ip
          secret: false
          deprecated: false
        - name: _pre_process
          required: false
          default: false
          description: ""
          auto: null
          predefined: []
          isArray: false
          defaultValue: null
          secret: false
          deprecated: false
        - name: _post_process
          required: false
          default: false
          description: ""
          auto: null
          predefined: []
          isArray: false
          defaultValue: null
          secret: false
          deprecated: false
        - name: _path_param:ip
          required: true
          default: false
          description: ""
          auto: null
          predefined: []
          isArray: false
          defaultValue: ""
          secret: false
          deprecated: false
      outputs: []
      timeout: null
      hidden: false
      polling: false
  runonce: false
  subtype: python3
  feed: false
  isFetchSamples: false
  resetContext: false
system: false
hidden: false
versionedfields: ""
defaultEnabled: false
tests:
  - no tests
scriptNotVisible: false
autoUpdateDockerImage: true
